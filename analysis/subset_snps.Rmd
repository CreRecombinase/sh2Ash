---
title: "Subsetting SNPs"
author: "Jean Morrison"
date: "November 15, 2017"
output: html_document
---

```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```


<!-- Insert the code version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r code-version, echo=FALSE, results='asis'}
```


## Introduction

My goal is to understand two questions:

1. Given a decent estimate of the posterior distributions of $b$ and $q$, can I use only a subset of SNPs to estimate the difference in ELPD between the shared and causal models.

2. Can I get a reasonable estimate of the posterior using only a subset of SNPs

In both cases, I am interested in subsetting SNPs using $p$-values from the first trait.

In these experiments, I will use two simluted data sets. Both have 100,000 SNPs. Data set S is generated under the shared model with $q=0.5$ and $b=0.4$. Data set C genrated under the causal model with $q=1$ and $b=0.4$. 


## Likelihood ratios using known parameters
First we assume the value of $b$ is known. We look at log likelihood ratios comparing $q=1$ to $q=0.5$ and $q=1$ to $q=0$.

```{r, echo = FALSE, fig.show='hold', ll_known}
library(tidyr)
library(ggplot2)
library(sherlockAsh)
library(gridExtra)
library(cumstats)
library(knitr)
draw_s <- readRDS("../data/shared_draw.RDS")
draw_c  <- readRDS("../data/causal_draw.RDS")
s_oracle_ix <- with(draw_s$dat, which(b1!=0))
c_oracle_ix <- with(draw_c$dat, which(b1!=0))

s_ll <- data.frame(
  with(draw_s, ll_v4_loo(rep(0, 3), rep(0.4, 3), c(1, 0.5, 0),
                  grid$S1, grid$S2, grid$pi,
                  dat$beta_hat_1, dat$beta_hat_2, dat$seb1, dat$seb2))
)
c_ll <- data.frame(
  with(draw_c, ll_v4_loo(rep(0, 3), rep(0.4, 3), c(1, 0.5, 0),
                  grid$S1, grid$S2, grid$pi,
                  dat$beta_hat_1, dat$beta_hat_2, dat$seb1, dat$seb2))
)
names(s_ll) <- names(c_ll) <- c("q1", "q0.5", "q0")
```

```{r, plot_ll_known}
order_s <- with(draw_s$dat, order(abs(beta_hat_1/seb1), decreasing = TRUE))
order_c <- with(draw_c$dat, order(abs(beta_hat_1/seb1), decreasing = TRUE))

df_q1_q0.5 <- data.frame(
  n = (1:100000),
  "S" = with(s_ll[order_s,] , cumsum(q1-q0.5)),
  "C" = with(c_ll[order_c,] , cumsum(q1-q0.5))
)
df_q1_q0 <- data.frame(
  n = (1:100000),
  "S" = with(s_ll[order_s,] , cumsum(q1-q0)),
  "C" = with(c_ll[order_c,] , cumsum(q1-q0))
)

df_long <- gather(df_q1_q0.5, "data_set", "ll_ratio", -n)

df_lines <- data.frame(data_set = rep(c("C", "S")), val=rep(c("oracle_only", "all"), each=2), "llr" = NA)
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="oracle_only"] <- with(s_ll, sum((q1-q0.5)[s_oracle_ix]))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="oracle_only"] <- with(c_ll, sum((q1-q0.5)[s_oracle_ix]))
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="all"] <- with(s_ll, sum(q1-q0.5))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="all"] <-  with(c_ll, sum(q1-q0.5))

plt1 <- ggplot(df_long) + geom_line(aes(x=n, y=ll_ratio, color=data_set)) +
        geom_hline(data = df_lines, aes(yintercept=llr, color=data_set, linetype=val)) +
        scale_linetype_manual(values=2:3) + 
        ggtitle("Log likelihood ratio: q = 1 to q=0.5") + 
        labs(x="Number of SNPs included", y="Log Likelihood Ratio") + 
        theme_bw()


df_long <- gather(df_q1_q0, "data_set", "ll_ratio", -n)

df_lines <- data.frame(data_set = rep(c("C", "S")), val=rep(c("oracle_only", "all"), each=2), "llr" = NA)
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="oracle_only"] <- with(s_ll, sum((q1-q0)[s_oracle_ix]))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="oracle_only"] <- with(c_ll, sum((q1-q0)[s_oracle_ix]))
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="all"] <- with(s_ll, sum(q1-q0))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="all"] <-  with(c_ll, sum(q1-q0))

plt2 <- ggplot(df_long) + geom_line(aes(x=n, y=ll_ratio, color=data_set)) + 
        geom_hline(data = df_lines, aes(yintercept=llr, color=data_set, linetype=val)) +
        scale_linetype_manual(values=2:3) + 
        ggtitle("Log likelihood ratio: q = 1 to q=0") + 
        labs(x="Number of SNPs included", y="Log Likelihood Ratio") + 
        theme_bw()
grid.arrange(plt1 + scale_x_continuous(limits=c(0, 5000)),
                  plt2 + scale_x_continuous(limits=c(0, 5000)) , ncol=2)
```

In both data sets, with a small number of SNPs (1 or 2\% of the top trait 1 SNPs) we can do a good job of approximating the log likelihood ratio we would obtain with all the SNPs. Horizontal lines show the log likelihood ratio we would obtain using only the SNPs for which the true trait 1 effect size is not zero (which we will call the "oracle" SNP set). 
Note that when we include the top few percent of SNPs, we retain fewer than half of the true trait 1 effect SNPs. The plot below shows the number of SNPs retained  vs the proprtion of true effect SNPs retained (both data sets contain `r length(c_oracle_ix)` trait 1 effects). SNPs in both data sets have the same trait 1 effects so the difference between these two lines is due to stochasitic differences in $\hat{\beta}_1$.

```{r, echo=FALSE, plot2}
plot(cumsum(order_c %in% c_oracle_ix)/length(c_oracle_ix), type="l", 
     xlab="Number of SNPs retained", ylab="Proportion of true effects retained") 
lines(cumsum(order_s %in% s_oracle_ix)/length(s_oracle_ix), lty=2)
legend("bottomright", legend=c("data set C", "data set S"), lty=c(1, 2))
```

## "Oracle" posteriors

Now we consider comparing the ELPD under the causal model to the ELPD under the shared model. For the causal model, we use the data to estimate the posterior distribution of $b$. For the shared model we estimate the posteriors of $b$ and $q$. 

We start with the best possible posterior distribution we can get from these data. To estimate the "oracle" posterior, we use only SNPs with non-zero true effects on trait 1 and we assume we know the joint distribution of direct effects on trait 1 and trait 2. We also assume we know $\rho=0$.

The plots below show the marginal posterior distributions of $b$ and $q$ from the shared models and the posterior of $b$ from the causal model. 

```{r, cache=TRUE, fig.show='hold', fig.width=11, echo=FALSE, oracle_posterior}
c_grid <- subset(draw_c$grid, S1!=0)
c_grid$pi <- with(c_grid, pi/sum(pi))
out_oracle_c <- cause_grid_approx(dat = draw_c$dat[c_oracle_ix,],
                                       mix_grid = c_grid, rho=0, waic_samps = -1)
  
s_grid <- subset(draw_s$grid, S1!=0)
s_grid$pi <- with(s_grid, pi/sum(pi))
out_oracle_s <- cause_grid_approx(dat = draw_s$dat[s_oracle_ix,],
                                       mix_grid = s_grid, rho=0, waic_samps = -1)
df_b <- data.frame("b" = out_oracle_c$marge_b$b,
                   "C_causal_model" = out_oracle_c$marge_b$m2,
                   "C_shared_model" = out_oracle_c$marge_b$m3,
                   "S_causal_model" = out_oracle_s$marge_b$m2,
                   "S_shared_model" = out_oracle_s$marge_b$m3
)
df_q <- data.frame("q" = out_oracle_c$marge_q$q,
                   "C_shared_model" = out_oracle_c$marge_q$m3,
                   "S_shared_model" = out_oracle_s$marge_q$m3
)
df_b_long <- gather(df_b, "mod", "posterior", -b)
df_b_long$data_set <- "C"
df_b_long$data_set[grep("S", df_b_long$mod)] <- "S"
df_b_long$model <- "shared"
df_b_long$model[grep("causal", df_b_long$mod)] <- "causal"
df_b_long$model <- factor(df_b_long$model, levels=c("shared", "causal"))
pltb <- ggplot(df_b_long) + geom_line(aes(x=b, y=posterior, color=data_set, lty=model), alpha=0.5) +
  ggtitle("Marginal Posteriors - b") + 
  theme_bw() 

df_q_long <- gather(df_q, "mod", "posterior", -q)
df_q_long$data_set <- "C"
df_q_long$data_set[grep("S", df_q_long$mod)] <- "S"
pltq <- ggplot(df_q_long) + geom_line(aes(x=q, y=posterior, color=data_set), alpha=0.5) + 
  ggtitle("Marginal Posteriors - q (shared model only)") + 
  theme_bw() 

grid.arrange(pltb, pltq, ncol=2)
```

We now estimate the difference in ELPD from these two posterior distributions using subsets of the SNPs. The plots below show the $z$-score for the change in ELPD between the causal model and the shared model using only a subset of SNPs (number of SNPs included on horizontal axis). The dotted lines show the $z$-scores we would obtain using only the true trait 1 effect SNPs. The dashed line shows the $z$-score obtained using all SNPs. In this plot, positive $z$-scores are evidence for the shared model and negative $z$-scores are evidence for the causal model. 

```{r, cache=TRUE, echo=FALSE, ll_oracle_posterior}
ll_c_causal <- with(draw_c, samp_from_grid_ll(post_grid = out_oracle_c$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_c_shared <- with(draw_c, samp_from_grid_ll(post_grid = out_oracle_c$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_c <- my_waic(list(ll_c_causal, ll_c_shared))
ll_s_causal <- with(draw_s, samp_from_grid_ll(post_grid = out_oracle_s$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_s_shared <- with(draw_s, samp_from_grid_ll(post_grid = out_oracle_s$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_s <- my_waic(list(ll_s_causal, ll_s_shared))
```

```{r, cache=TRUE,  echo=FALSE, plot_oracle_posterior}
df <- data.frame(
  n = 1:5000,
  "S_sum" = with(waic_s, cumsum((py[,2]-py[,1])[order_s[1:5000]])),
  "C_sum" = with(waic_c, cumsum((py[,2]-py[,1])[order_c[1:5000]])),
  "S_var" = with(waic_s, cumvar((py[,2]-py[,1])[order_s[1:5000]])),
  "C_var" = with(waic_c, cumvar((py[,2]-py[,1])[order_s[1:5000]]))
)
df$S <- with(df, S_sum/(sqrt(n)*sqrt(S_var)))
df$C <- with(df, C_sum/(sqrt(n)*sqrt(C_var)))
df_long <- gather(df[, c("n", "S", "C")], "data_set", "delta_elpd_z_score", -n)

df_lines <- data.frame(data_set = rep(c("C", "S")), val=rep(c("oracle_only", "all"), each=2), "llr" = NA)
d <- with(waic_s, (py[,2]-py[,1])[s_oracle_ix])
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1])[c_oracle_ix])
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))

d <- with(waic_s, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))


plt <- ggplot(df_long) + geom_line(aes(x=n, y=delta_elpd_z_score, color=data_set)) +
        geom_hline(data = df_lines, aes(yintercept=llr, color=data_set, linetype=val)) +
        scale_linetype_manual(values=2:3) + 
        labs(x="Number of SNPs included", y="Delta ELPD z-score") + 
        theme_bw()
plt
```

```{r, echo=FALSE, res_tab1}
res_tab_s <- res_tab_c <- data.frame("snp_set" = c("Oracle", "All", "Top 1%"), oracle = NA, 
                      all=NA, top=NA)
res_tab_s$oracle[1] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="oracle_only"]
res_tab_c$oracle[1] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="oracle_only"]

res_tab_s$oracle[2] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="all"]
res_tab_c$oracle[2] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="all"]

res_tab_s$oracle[3] <- df$S[1000]
res_tab_c$oracle[3] <- df$C[1000]
```


We find that we can approximate the delta ELPD $z$-score that we would obtain from the full set of SNPs using a few thousand of the top SNPs. Data set S shows strong evidence in favor of the shared model as we expect. Data set C shows evidence in favor of the causal model -- $z$-score of `r round(df_lines$llr[df_lines$data_set=="C" & df_lines$val=="all"], digits=2)` using all SNPs. This $z$-score is not larger because the posterior for $q$ is very close to 1 and the posteriors for $b$ are very similar under the two models. This makes the posterior distribution under the shared model for data set C look very similar to the posterior under the causal model.

## Posteriors estimated with all SNPs

Now we consider the posteriors that we would get using all the SNPs and without knowing the true joint distribution of direct effects on traits 1 and 2. 


```{r, cache=TRUE, fig.show='hold', fig.width=11, echo=FALSE, all_posterior}
#out_all_c <- cause_grid_approx(dat = draw_c$dat, seed = 568724760,
#                                       mix_grid = draw_c$grid, rho=0, waic_samps = -1)
out_all_c <- readRDS("../data/out_all_c.RDS")  
#out_all_s <- cause_grid_approx(dat = draw_s$dat, seed = 330178822,
#                               mix_grid = draw_s$grid, rho=0, waic_samps = -1)
out_all_s <- readRDS("../data/out_all_s.RDS") 
```


```{r, cache=TRUE, fig.show='hold', fig.width=11, echo=FALSE, all_posterior_plot}
df_b <- data.frame("b" = out_all_c$marge_b$b,
                   "C_causal_model" = out_all_c$marge_b$m2,
                   "C_shared_model" = out_all_c$marge_b$m3,
                   "S_causal_model" = out_all_s$marge_b$m2,
                   "S_shared_model" = out_all_s$marge_b$m3
)
df_q <- data.frame("q" = out_all_c$marge_q$q,
                   "C_shared_model" = out_all_c$marge_q$m3,
                   "S_shared_model" = out_all_s$marge_q$m3
)
df_b_long <- gather(df_b, "mod", "posterior", -b)
df_b_long$data_set <- "C"
df_b_long$data_set[grep("S", df_b_long$mod)] <- "S"
df_b_long$model <- "shared"
df_b_long$model[grep("causal", df_b_long$mod)] <- "causal"
df_b_long$model <- factor(df_b_long$model, levels=c("shared", "causal"))
pltb <- ggplot(df_b_long) + geom_line(aes(x=b, y=posterior, color=data_set, lty=model), alpha=0.5) +
  ggtitle("Marginal Posteriors - b") + 
  theme_bw() 

df_q_long <- gather(df_q, "mod", "posterior", -q)
df_q_long$data_set <- "C"
df_q_long$data_set[grep("S", df_q_long$mod)] <- "S"
pltq <- ggplot(df_q_long) + geom_line(aes(x=q, y=posterior, color=data_set), alpha=0.5) + 
  ggtitle("Marginal Posteriors - q\n(shared model only)") + 
  theme_bw() 

grid.arrange(pltb, pltq, ncol=2)
```

These posteriors differ from the posteriors calculated using only the true trait 1 effects in a few ways:

+ The posteriors of $b$ for data set S under the causal and shared models are lower. 
+ The posteriors of $q$ for both data sets are somewhat lower. The MAP for data set $S$ is around `r with(out_all_s$marge_q, round(q[which.max(m3)], digits=2))` using all SNPs while it was around `r with(out_oracle_s$marge_q, round(q[which.max(m3)], digits=2))` using only the oracle SNPs.
+ The posteriors for $b$ under both models for data set C are similar to those estimated with only the oracle SNPs.

Using these priors to calculate $\Delta$ ELPD $z$-scores gives the following results:

```{r, cache=TRUE, echo=FALSE, ll_all_posterior}
ll_c_causal <- with(draw_c, samp_from_grid_ll(post_grid = out_all_c$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_c_shared <- with(draw_c, samp_from_grid_ll(post_grid = out_all_c$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_c <- my_waic(list(ll_c_causal, ll_c_shared))
ll_s_causal <- with(draw_s, samp_from_grid_ll(post_grid = out_all_s$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_s_shared <- with(draw_s, samp_from_grid_ll(post_grid = out_all_s$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_s <- my_waic(list(ll_s_causal, ll_s_shared))
```

```{r, cache=TRUE,  echo=FALSE, plot_all_posterior}
df <- data.frame(
  n = 1:5000,
  "S_sum" = with(waic_s, cumsum((py[,2]-py[,1])[order_s[1:5000]])),
  "C_sum" = with(waic_c, cumsum((py[,2]-py[,1])[order_c[1:5000]])),
  "S_var" = with(waic_s, cumvar((py[,2]-py[,1])[order_s[1:5000]])),
  "C_var" = with(waic_c, cumvar((py[,2]-py[,1])[order_s[1:5000]]))
)
df$S <- with(df, S_sum/(sqrt(n)*sqrt(S_var)))
df$C <- with(df, C_sum/(sqrt(n)*sqrt(C_var)))
df_long <- gather(df[, c("n", "S", "C")], "data_set", "delta_elpd_z_score", -n)

df_lines <- data.frame(data_set = rep(c("C", "S")), val=rep(c("oracle_only", "all"), each=2), "llr" = NA)
d <- with(waic_s, (py[,2]-py[,1])[s_oracle_ix])
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1])[c_oracle_ix])
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))

d <- with(waic_s, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))

plt <- ggplot(df_long) + geom_line(aes(x=n, y=delta_elpd_z_score, color=data_set)) +
        geom_hline(data = df_lines, aes(yintercept=llr, color=data_set, linetype=val)) +
        scale_linetype_manual(values=2:3) + 
        labs(x="Number of SNPs included", y="Delta ELPD z-score") + 
        theme_bw()
plt
```


```{r, echo=FALSE, res_tab2}
res_tab_s$all[1] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="oracle_only"]
res_tab_c$all[1] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="oracle_only"]

res_tab_s$all[2] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="all"]
res_tab_c$all[2] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="all"]

res_tab_s$all[3] <- df$S[1000]
res_tab_c$all[3] <- df$C[1000]
```

## Posteriors estimated with top SNPs 

Now we estimate the posteriors using only the top 1000 SNPs. We still assume we know the joint distribution of direct effects.

```{r, cache=TRUE, fig.show='hold', fig.width=11, echo=FALSE, top_posterior}
out_top_c <- cause_grid_approx(dat = draw_c$dat[order_c[1:1000],], 
                                       mix_grid = draw_c$grid, rho=0, waic_samps = -1)
out_top_s <- cause_grid_approx(dat = draw_s$dat[order_s[1:1000],],
                               mix_grid = draw_s$grid, rho=0, waic_samps = -1)
```

```{r, cache=TRUE, fig.show='hold', fig.width=11, echo=FALSE, top_posterior_plot}
df_b <- data.frame("b" = out_top_c$marge_b$b,
                   "C_causal_model" = out_top_c$marge_b$m2,
                   "C_shared_model" = out_top_c$marge_b$m3,
                   "S_causal_model" = out_top_s$marge_b$m2,
                   "S_shared_model" = out_top_s$marge_b$m3
)
df_q <- data.frame("q" = out_top_c$marge_q$q,
                   "C_shared_model" = out_top_c$marge_q$m3,
                   "S_shared_model" = out_top_s$marge_q$m3
)
df_b_long <- gather(df_b, "mod", "posterior", -b)
df_b_long$data_set <- "C"
df_b_long$data_set[grep("S", df_b_long$mod)] <- "S"
df_b_long$model <- "shared"
df_b_long$model[grep("causal", df_b_long$mod)] <- "causal"
df_b_long$model <- factor(df_b_long$model, levels=c("shared", "causal"))
pltb <- ggplot(df_b_long) + geom_line(aes(x=b, y=posterior, color=data_set, lty=model), alpha=0.5) +
  ggtitle("Marginal Posteriors - b") + 
  theme_bw() 

df_q_long <- gather(df_q, "mod", "posterior", -q)
df_q_long$data_set <- "C"
df_q_long$data_set[grep("S", df_q_long$mod)] <- "S"
pltq <- ggplot(df_q_long) + geom_line(aes(x=q, y=posterior, color=data_set), alpha=0.5) + 
  ggtitle("Marginal Posteriors - q\n(shared model only)") + 
  theme_bw() 

grid.arrange(pltb, pltq, ncol=2)
```



```{r, cache=TRUE, echo=FALSE, ll_top_posterior}
ll_c_causal <- with(draw_c, samp_from_grid_ll(post_grid = out_top_c$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_c_shared <- with(draw_c, samp_from_grid_ll(post_grid = out_top_c$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_c <- my_waic(list(ll_c_causal, ll_c_shared))
ll_s_causal <- with(draw_s, samp_from_grid_ll(post_grid = out_top_s$post[[1]], rho = 0, 
                                 mix_grid=grid, dat=dat, fix.q=1))
ll_s_shared <- with(draw_s, samp_from_grid_ll(post_grid = out_top_s$post[[2]], rho = 0, 
                                 mix_grid=grid, dat=dat))
waic_s <- my_waic(list(ll_s_causal, ll_s_shared))
```

```{r, cache=TRUE,  echo=FALSE, plot_top_posterior}
df <- data.frame(
  n = 1:5000,
  "S_sum" = with(waic_s, cumsum((py[,2]-py[,1])[order_s[1:5000]])),
  "C_sum" = with(waic_c, cumsum((py[,2]-py[,1])[order_c[1:5000]])),
  "S_var" = with(waic_s, cumvar((py[,2]-py[,1])[order_s[1:5000]])),
  "C_var" = with(waic_c, cumvar((py[,2]-py[,1])[order_s[1:5000]]))
)
df$S <- with(df, S_sum/(sqrt(n)*sqrt(S_var)))
df$C <- with(df, C_sum/(sqrt(n)*sqrt(C_var)))
df_long <- gather(df[, c("n", "S", "C")], "data_set", "delta_elpd_z_score", -n)

df_lines <- data.frame(data_set = rep(c("C", "S")), val=rep(c("oracle_only", "all"), each=2), "llr" = NA)
d <- with(waic_s, (py[,2]-py[,1])[s_oracle_ix])
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1])[c_oracle_ix])
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="oracle_only"] <- sum(d)/(sqrt(length(d))*sd(d))

d <- with(waic_s, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="S" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))
d <- with(waic_c, (py[,2]-py[,1]))
df_lines$llr[ df_lines$data_set=="C" & df_lines$val=="all"] <- sum(d)/(sqrt(length(d))*sd(d))

plt <- ggplot(df_long) + geom_line(aes(x=n, y=delta_elpd_z_score, color=data_set)) +
        geom_hline(data = df_lines, aes(yintercept=llr, color=data_set, linetype=val)) +
        scale_linetype_manual(values=2:3) + 
        labs(x="Number of SNPs included", y="Delta ELPD z-score") + 
        theme_bw()
plt
```


```{r, echo=FALSE, res_tab3}
res_tab_s$top[1] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="oracle_only"]
res_tab_c$top[1] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="oracle_only"]

res_tab_s$top[2] <- df_lines$llr[df_lines$data_set=="S" & df_lines$val=="all"]
res_tab_c$top[2] <- df_lines$llr[df_lines$data_set=="C" & df_lines$val=="all"]

res_tab_s$top[3] <- df$S[1000]
res_tab_c$top[3] <- df$C[1000]
cat("Data set S\n")
kable(res_tab_s)
cat("Data set C\n")
kable(res_tab_c)
```






## Session information

<!-- Insert the session information into the document -->
```{r session-info}
```
